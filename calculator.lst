     1                                  section .data
     2 00000000 5175616C206F207365-     	welcome_msg db	'Qual o seu nome? ',0
     2 00000009 75206E6F6D653F2000 
     3                                  	welcome_msg_size	EQU	$-welcome_msg
     4                                  
     5 00000012 48C3B36C612C2000        	hello_msg db	'Hóla, ',0
     6                                  	hello_msg_size	EQU	$-hello_msg
     7                                  
     8 0000001A 2C2062656D2D76696E-     	hello_cont db	', bem-vindo ao programa de CALC IA-32',0
     8 00000023 646F20616F2070726F-
     8 0000002C 6772616D6120646520-
     8 00000035 43414C432049412D33-
     8 0000003E 3200               
     9                                  	hello_cont_size	EQU	$-hello_cont
    10                                  
    11 00000040 4553434F4C48412055-     	choose_msg	db	'ESCOLHA UMA OPÇÃO:',0dh,0ah
    11 00000049 4D41204F50C387C383-
    11 00000052 4F3A0D0A           
    12                                  	choose_msg_size	EQU	$-choose_msg
    13                                  
    14 00000056 2D313A20534F4D410D-     	sum_msg	db	'-1: SOMA',0dh,0ah
    14 0000005F 0A                 
    15                                  	sum_msg_size EQU	$-sum_msg
    16                                  
    17 00000060 2D323A205355425452-     	sub_msg	db	'-2: SUBTRAÇÃO',0dh,0ah
    17 00000069 41C387C3834F0D0A   
    18                                  	sub_msg_size EQU	$-sub_msg
    19                                  
    20 00000071 2D333A204D554C5449-     	mul_msg	db	'-3: MULTIPLICAÇÃO',0dh,0ah
    20 0000007A 504C494341C387C383-
    20 00000083 4F0D0A             
    21                                  	mul_msg_size EQU	$-mul_msg
    22                                  
    23 00000086 2D343A204449564953-     	div_msg	db	'-4: DIVISÃO',0dh,0ah
    23 0000008F C3834F0D0A         
    24                                  	div_msg_size EQU	$-div_msg
    25                                  
    26 00000094 2D353A204D4F440D0A      	mod_msg	db	'-5: MOD',0dh,0ah
    27                                  	mod_msg_size EQU	$-mod_msg
    28                                  
    29 0000009D 2D363A20534149520D-     	quit_msg	db	'-6: SAIR',0dh,0ah
    29 000000A6 0A                 
    30                                  	quit_msg_size EQU	$-quit_msg
    31                                  
    32 000000A7 446967697465206F20-     	op1_msg db	'Digite o primeiro argumento da operação: ',0
    32 000000B0 7072696D6569726F20-
    32 000000B9 617267756D656E746F-
    32 000000C2 206461206F70657261-
    32 000000CB C3A7C3A36F3A2000   
    33                                  	op1_msg_size	EQU	$-op1_msg
    34                                  
    35 000000D3 446967697465206F20-     	op2_msg db	'Digite o segundo argumento da operação: ',0
    35 000000DC 736567756E646F2061-
    35 000000E5 7267756D656E746F20-
    35 000000EE 6461206F70657261C3-
    35 000000F7 A7C3A36F3A2000     
    36                                  	op2_msg_size	EQU	$-op2_msg
    37                                  
    38 000000FE 4F20726573756C7461-     	result_msg db	'O resultado é: ',0
    38 00000107 646F20C3A93A2000   
    39                                  	result_msg_size	EQU	$-result_msg
    40                                  
    41 0000010F 0D0A                    	new_line	db	0Dh, 0Ah
    42                                  	new_line_size	EQU	$-new_line
    43                                  
    44 00000111 5072657373696F6E65-     	press_enter_msg db 'Pressione enter para voltar ao menu',0
    44 0000011A 20656E746572207061-
    44 00000123 726120766F6C746172-
    44 0000012C 20616F206D656E7500 
    45                                  	press_enter_size EQU $-press_enter_msg
    46                                  
    47                                  
    48                                  section .bss
    49 00000000 <res 00000010>          	user_name	resb	16	; nome do usuário da calculadora
    50 00000010 <res 00000001>          	option	resb	1	; menu option
    51 00000011 <res 0000000B>          	arg1	resb	11	; operandos com até 32 bits (10 algarismos)
    52 0000001C <res 0000000B>          	arg2	resb	11	; operandos com até 32 bits (10 algarismos)
    53 00000027 <res 0000000B>          	resposta resb   11  ; Resultado da operacao
    54 00000032 <res 00000004>          	arg1Int resd	1	; Inteiro do argumento 1
    55 00000036 <res 00000004>          	arg2Int	resd	1	; Inteiro do argumento 2
    56                                  
    57                                  section .text
    58                                  global _start
    59                                  _start:
    60                                  
    61                                  ; Qual o seu nome?
    62 00000000 6A12                    	push welcome_msg_size
    63 00000002 68[00000000]            	push welcome_msg
    64 00000007 E895030000              	call put_string
    65                                  
    66                                  ; Get user_name
    67 0000000C 6A10                    	push 16
    68 0000000E 68[00000000]            	push user_name
    69 00000013 E8A0030000              	call get_string
    70                                  
    71                                  ; 'Hóla, '
    72 00000018 6A08                    	push hello_msg_size
    73 0000001A 68[12000000]            	push hello_msg
    74 0000001F E87D030000              	call put_string
    75                                  
    76                                  ; 'user_name'
    77 00000024 68[00000000]            	push user_name
    78 00000029 E84C030000              	call put_name
    79                                  
    80                                  ; ', bem-vindo ao programa de CALC IA-32'
    81 0000002E 6A26                    	push hello_cont_size
    82 00000030 68[1A000000]            	push hello_cont
    83 00000035 E867030000              	call put_string
    84                                  	; Imprime uma new line no terminal
    85 0000003A 6A02                    	push new_line_size
    86 0000003C 68[0F010000]            	push new_line
    87 00000041 E85B030000              	call put_string
    88                                  
    89                                  menu:
    90 00000046 C705[32000000]0000-     	mov dword [arg1Int],0
    90 0000004E 0000               
    91 00000050 C705[36000000]0000-     	mov dword [arg2Int],0
    91 00000058 0000               
    92 0000005A C705[27000000]0000-     	mov dword [resposta],0
    92 00000062 0000               
    93                                  	;Imprime uma new line no terminal
    94 00000064 6A02                    	push new_line_size
    95 00000066 68[0F010000]            	push new_line
    96 0000006B E831030000              	call put_string
    97                                  
    98                                  	; Escolha uma opcao:
    99 00000070 6A16                    	push choose_msg_size
   100 00000072 68[40000000]            	push choose_msg
   101 00000077 E825030000              	call put_string
   102                                  
   103                                  ; add operation
   104 0000007C 6A0A                    	push sum_msg_size
   105 0000007E 68[56000000]            	push sum_msg
   106 00000083 E819030000              	call put_string
   107                                  
   108                                  ; sub operation
   109 00000088 6A11                    	push sub_msg_size
   110 0000008A 68[60000000]            	push sub_msg
   111 0000008F E80D030000              	call put_string
   112                                  
   113                                  ; mul operation
   114 00000094 6A15                    	push mul_msg_size
   115 00000096 68[71000000]            	push mul_msg
   116 0000009B E801030000              	call put_string
   117                                  
   118                                  ; div operation
   119 000000A0 6A0E                    	push div_msg_size
   120 000000A2 68[86000000]            	push div_msg
   121 000000A7 E8F5020000              	call put_string
   122                                  
   123                                  ; mod operation:
   124 000000AC 6A09                    	push mod_msg_size
   125 000000AE 68[94000000]            	push mod_msg
   126 000000B3 E8E9020000              	call put_string
   127                                  
   128 000000B8 6A0A                    	push quit_msg_size
   129 000000BA 68[9D000000]            	push quit_msg
   130 000000BF E8DD020000              	call put_string
   131                                  
   132                                  ; get operation:
   133 000000C4 6A01                    	push 1
   134 000000C6 68[10000000]            	push option
   135 000000CB E8E8020000              	call get_string
   136                                  
   137                                  	; Faz a logica do menu e a opcao selecionada
   138                                  
   139 000000D0 803D[10000000]31        	cmp byte [option], 31h	; 1d = 31h
   140 000000D7 7470                    	je	add_operation
   141                                  	
   142 000000D9 803D[10000000]32        	cmp byte [option], 32h	; 2d = 32h
   143 000000E0 0F84C8000000            	je	sub_operation
   144                                  	
   145 000000E6 803D[10000000]33        	cmp byte [option], 33h	; 3d = 33h
   146 000000ED 0F8420010000            	je	mul_operation
   147                                  	
   148 000000F3 803D[10000000]34        	cmp byte [option], 34h	; 4d = 34h
   149 000000FA 0F8405020000            	je	div_operation
   150                                  	
   151 00000100 803D[10000000]35        	cmp byte [option], 35h	; 5d = 35h
   152 00000107 0F8483010000            	je	mod_operation
   153                                  	
   154                                  	;cmp byte [option], 36h	; 6d = 36h
   155                                  	;jne menu
   156                                  
   157                                  return:
   158 0000010D B801000000              	mov eax, 1			; sys_exit
   159 00000112 BB00000000              	mov ebx, 0
   160 00000117 CD80                    	int 80h
   161                                  
   162                                  
   163                                  
   164                                  
   165                                  
   166                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   167                                  ; PROCEDURE
   168                                  ;
   169                                  espera:
   170 00000119 6A02                    	push new_line_size
   171 0000011B 68[0F010000]            	push new_line
   172 00000120 E87C020000              	call put_string
   173 00000125 6A24                    	push press_enter_size
   174 00000127 68[11010000]            	push press_enter_msg
   175 0000012C E870020000              	call put_string
   176 00000131 68[10000000]            	push option
   177 00000136 E87D020000              	call get_string
   178 0000013B 803D[10000000]0A        	cmp byte [option], 0ah
   179 00000142 75D5                    	jne espera
   180 00000144 E9FDFEFFFF              	jmp menu
   181                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   182                                  ; PROCEDURE - ADICAO
   183                                  ;
   184                                  add_operation:
   185                                  	; mensagem para Digitar o primeiro arg
   186 00000149 6A2C                    	push op1_msg_size
   187 0000014B 68[A7000000]            	push op1_msg
   188 00000150 E84C020000              	call put_string
   189                                  	; Funcao para pegar a string e retornar inteiro
   190                                  	; Recebe como argumento o lugar para guardar o inteiro e o lugar da string
   191                                  	
   192 00000155 68[32000000]            	push arg1Int	; Lugar para guardar o inteiro 	
   193 0000015A 68[11000000]            	push arg1		; Lugar para armazenar a string do inteiro
   194 0000015F E86B020000              	call get_signed_int
   195                                  
   196 00000164 A1[32000000]            	mov eax,[arg1Int] ;Coloca o numero inteiro no EAX
   197                                  
   198                                  ; Pegar o 2 numero
   199 00000169 6A2B                    	push op2_msg_size
   200 0000016B 68[D3000000]            	push op2_msg
   201 00000170 E82C020000              	call put_string
   202                                  
   203 00000175 68[36000000]            	push arg2Int	; Lugar para guardar o inteiro 	
   204 0000017A 68[1C000000]            	push arg2		; Lugar para armazenar a string do inteiro
   205 0000017F E84B020000              	call get_signed_int
   206                                  	
   207                                  	
   208                                  	;O resultado é 
   209 00000184 6A11                    	push result_msg_size
   210 00000186 68[FE000000]            	push result_msg
   211 0000018B E811020000              	call put_string
   212                                  	
   213                                  	; é feito a soma dois dois
   214 00000190 A1[32000000]            	mov eax,[arg1Int]
   215 00000195 8B1D[36000000]          	mov	ebx,[arg2Int]
   216 0000019B 01D8                    	add eax,ebx
   217 0000019D B90A000000              	mov ecx , 10
   218                                  
   219 000001A2 50                      	push eax ; Numero que se deseja escrever na tela
   220 000001A3 51                      	push ecx ; Tamanho do numero inteiro
   221                                  
   222 000001A4 E87E020000              	call int_to_string
   223                                  		
   224 000001A9 E96BFFFFFF              	jmp espera
   225                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   226                                  ; PROCEDURE - SUBTRACAO
   227                                  ;
   228                                  sub_operation:
   229                                  ; mensagem para Digitar o primeiro arg
   230 000001AE 6A2C                    	push op1_msg_size
   231 000001B0 68[A7000000]            	push op1_msg
   232 000001B5 E8E7010000              	call put_string
   233                                  	; Funcao para pegar a string e retornar inteiro
   234                                  	; Recebe como argumento o lugar para guardar o inteiro e o lugar da string
   235                                  	
   236 000001BA 68[32000000]            	push arg1Int	; Lugar para guardar o inteiro 	
   237 000001BF 68[11000000]            	push arg1		; Lugar para armazenar a string do inteiro
   238 000001C4 E806020000              	call get_signed_int
   239                                  
   240 000001C9 A1[32000000]            	mov eax,[arg1Int] ;Coloca o numero inteiro no EAX
   241                                  
   242                                  ; Pegar o 2 numero
   243 000001CE 6A2B                    	push op2_msg_size
   244 000001D0 68[D3000000]            	push op2_msg
   245 000001D5 E8C7010000              	call put_string
   246                                  
   247 000001DA 68[36000000]            	push arg2Int	; Lugar para guardar o inteiro 	
   248 000001DF 68[1C000000]            	push arg2		; Lugar para armazenar a string do inteiro
   249 000001E4 E8E6010000              	call get_signed_int
   250                                  	
   251                                  	
   252                                  	;O resultado é 
   253 000001E9 6A11                    	push result_msg_size
   254 000001EB 68[FE000000]            	push result_msg
   255 000001F0 E8AC010000              	call put_string
   256                                  	
   257                                  	; é feito a subtracao dos dois
   258 000001F5 A1[32000000]            	mov eax,[arg1Int]
   259 000001FA 8B1D[36000000]          	mov	ebx,[arg2Int]
   260 00000200 29D8                    	sub eax,ebx
   261 00000202 B90A000000              	mov ecx , 10
   262                                  
   263 00000207 50                      	push eax ; Numero que se deseja escrever na tela
   264 00000208 51                      	push ecx ; Tamanho do numero inteiro
   265                                  
   266 00000209 E819020000              	call int_to_string
   267                                  		
   268 0000020E E906FFFFFF              	jmp espera
   269                                  
   270                                  
   271                                  
   272                                  
   273                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   274                                  ; PROCEDURE - MULTIPLICACAO
   275                                  ;
   276                                  ; mensagem para Digitar o primeiro arg
   277                                  mul_operation:
   278 00000213 6A2C                    	push op1_msg_size
   279 00000215 68[A7000000]            	push op1_msg
   280 0000021A E882010000              	call put_string
   281                                  	; Funcao para pegar a string e retornar inteiro
   282                                  	; Recebe como argumento o lugar para guardar o inteiro e o lugar da string
   283                                  	
   284 0000021F 68[32000000]            	push arg1Int	; Lugar para guardar o inteiro 	
   285 00000224 68[11000000]            	push arg1		; Lugar para armazenar a string do inteiro
   286 00000229 E8A1010000              	call get_signed_int
   287                                  
   288 0000022E A1[32000000]            	mov eax,[arg1Int] ;Coloca o numero inteiro no EAX
   289                                  
   290                                  ; Pegar o 2 numero
   291 00000233 6A2B                    	push op2_msg_size
   292 00000235 68[D3000000]            	push op2_msg
   293 0000023A E862010000              	call put_string
   294                                  
   295 0000023F 68[36000000]            	push arg2Int	; Lugar para guardar o inteiro 	
   296 00000244 68[1C000000]            	push arg2		; Lugar para armazenar a string do inteiro
   297 00000249 E881010000              	call get_signed_int
   298                                  	
   299                                  	
   300                                  	;O resultado é 
   301 0000024E 6A11                    	push result_msg_size
   302 00000250 68[FE000000]            	push result_msg
   303 00000255 E847010000              	call put_string
   304                                  	
   305                                  	; é feito a multiplicacao dos dois numeros
   306 0000025A A1[32000000]            	mov eax,[arg1Int]
   307 0000025F 8B1D[36000000]          	mov	ebx,[arg2Int]
   308 00000265 F7EB                    	imul ebx
   309 00000267 B90A000000              	mov ecx , 10
   310 0000026C 83EA00                  	sub edx,0				;Testa se edx = 0
   311 0000026F 750C                    	jnz multiplicacao64bits
   312                                  	
   313                                  
   314 00000271 50                      	push eax ; Numero que se deseja escrever na tela
   315 00000272 51                      	push ecx ; Tamanho do numero inteiro
   316                                  
   317 00000273 E8AF010000              	call int_to_string
   318                                  		
   319 00000278 E99CFEFFFF              	jmp espera
   320                                  multiplicacao64bits:
   321 0000027D 52                      	push edx ; Numero que se deseja escrever na tela
   322 0000027E 51                      	push ecx ; Tamanho do numero inteiro
   323                                  
   324 0000027F E8A3010000              	call int_to_string
   325                                  	
   326 00000284 50                      	push eax ; Numero que se deseja escrever na tela
   327 00000285 51                      	push ecx ; Tamanho do numero inteiro
   328                                  
   329 00000286 E89C010000              	call int_to_string
   330                                  		
   331 0000028B E989FEFFFF              	jmp espera
   332                                  
   333                                  
   334                                  
   335                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   336                                  ; PROCEDURE - MOD
   337                                  ;
   338                                  mod_operation:
   339                                  ; mensagem para Digitar o primeiro arg
   340 00000290 6A2C                    	push op1_msg_size
   341 00000292 68[A7000000]            	push op1_msg
   342 00000297 E805010000              	call put_string
   343                                  	; Funcao para pegar a string e retornar inteiro
   344                                  	; Recebe como argumento o lugar para guardar o inteiro e o lugar da string
   345                                  	
   346 0000029C 68[32000000]            	push arg1Int	; Lugar para guardar o inteiro 	
   347 000002A1 68[11000000]            	push arg1		; Lugar para armazenar a string do inteiro
   348 000002A6 E824010000              	call get_signed_int
   349                                  
   350 000002AB A1[32000000]            	mov eax,[arg1Int] ;Coloca o numero inteiro no EAX
   351                                  
   352                                  ; Pegar o 2 numero
   353 000002B0 6A2B                    	push op2_msg_size
   354 000002B2 68[D3000000]            	push op2_msg
   355 000002B7 E8E5000000              	call put_string
   356                                  
   357 000002BC 68[36000000]            	push arg2Int	; Lugar para guardar o inteiro 	
   358 000002C1 68[1C000000]            	push arg2		; Lugar para armazenar a string do inteiro
   359 000002C6 E804010000              	call get_signed_int
   360                                  	
   361                                  	
   362                                  	;O resultado é 
   363 000002CB 6A11                    	push result_msg_size
   364 000002CD 68[FE000000]            	push result_msg
   365 000002D2 E8CA000000              	call put_string
   366                                  	
   367                                  	; é feito a divisao dos dois
   368                                  teste:
   369 000002D7 A1[32000000]            	mov eax,[arg1Int]
   370 000002DC 8B1D[36000000]          	mov	ebx,[arg2Int]
   371 000002E2 29D2                    	sub edx,edx
   372                                  	; Verifica se eax é negativo
   373 000002E4 3DFFFFFF7F              	cmp eax,2147483647
   374 000002E9 7713                    	ja	extende_sinalmod
   375                                  continua_mod:
   376                                  	;idiv pega (EDX:EAX) / EBX
   377 000002EB F7FB                    	idiv ebx
   378 000002ED B90A000000              	mov ecx , 10
   379                                  
   380 000002F2 52                      	push edx ; Numero que se deseja escrever na tela
   381 000002F3 51                      	push ecx ; Tamanho do numero inteiro
   382                                  
   383 000002F4 E82E010000              	call int_to_string
   384                                  		
   385 000002F9 E91BFEFFFF              	jmp espera
   386                                  extende_sinalmod:
   387 000002FE BAFFFFFFFF              	mov edx,4294967295
   388 00000303 EBE6                    	jmp continua_mod
   389                                  
   390                                  
   391                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   392                                  ; PROCEDURE - Divisao
   393                                  ;
   394                                  
   395                                  div_operation:
   396                                  ; mensagem para Digitar o primeiro arg
   397 00000305 6A2C                    	push op1_msg_size
   398 00000307 68[A7000000]            	push op1_msg
   399 0000030C E890000000              	call put_string
   400                                  	; Funcao para pegar a string e retornar inteiro
   401                                  	; Recebe como argumento o lugar para guardar o inteiro e o lugar da string
   402                                  	
   403 00000311 68[32000000]            	push arg1Int	; Lugar para guardar o inteiro 	
   404 00000316 68[11000000]            	push arg1		; Lugar para armazenar a string do inteiro
   405 0000031B E8AF000000              	call get_signed_int
   406                                  
   407 00000320 A1[32000000]            	mov eax,[arg1Int] ;Coloca o numero inteiro no EAX
   408                                  
   409                                  ; Pegar o 2 numero
   410 00000325 6A2B                    	push op2_msg_size
   411 00000327 68[D3000000]            	push op2_msg
   412 0000032C E870000000              	call put_string
   413                                  
   414 00000331 68[36000000]            	push arg2Int	; Lugar para guardar o inteiro 	
   415 00000336 68[1C000000]            	push arg2		; Lugar para armazenar a string do inteiro
   416 0000033B E88F000000              	call get_signed_int
   417                                  	
   418                                  	
   419                                  	;O resultado é 
   420 00000340 6A11                    	push result_msg_size
   421 00000342 68[FE000000]            	push result_msg
   422 00000347 E855000000              	call put_string
   423                                  	
   424                                  	; é feito a divisao dos dois
   425 0000034C A1[32000000]            	mov eax,[arg1Int]
   426 00000351 8B1D[36000000]          	mov	ebx,[arg2Int]
   427 00000357 29D2                    	sub edx,edx
   428                                  	; Verifica se eax é negativo
   429 00000359 3DFFFFFF7F              	cmp eax,2147483647
   430 0000035E 7713                    	ja	extende_sinaldiv
   431                                  continua_div:
   432                                  	;idiv pega (EDX:EAX) / EBX
   433 00000360 F7FB                    	idiv ebx
   434 00000362 B90A000000              	mov ecx , 10
   435                                  
   436 00000367 50                      	push eax ; Numero que se deseja escrever na tela
   437 00000368 51                      	push ecx ; Tamanho do numero inteiro
   438                                  
   439 00000369 E8B9000000              	call int_to_string
   440                                  		
   441 0000036E E9A6FDFFFF              	jmp espera
   442                                  extende_sinaldiv:
   443 00000373 BAFFFFFFFF              	mov edx,4294967295
   444 00000378 EBE6                    	jmp continua_div
   445                                  
   446                                  
   447                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   448                                  ; PROCEDURE
   449                                  ;
   450                                  put_name:
   451 0000037A 29D2                    	sub edx, edx
   452 0000037C 8B4C2404                	mov ecx, [esp + 4]	; string pointer
   453                                  name:
   454 00000380 80390A                  	cmp byte [ecx], 0ah	; line feed character
   455 00000383 7409                    	je	final_name
   456 00000385 80390D                  	cmp byte [ecx], 13	; enter character
   457 00000388 7404                    	je	final_name
   458 0000038A 42                      	inc edx	; size name counter
   459 0000038B 41                      	inc ecx	; get next character
   460 0000038C EBF2                    	jmp name
   461                                  
   462                                  final_name:
   463 0000038E 8B4C2404                	mov ecx, [esp + 4]	; restart pointer to initial string character
   464 00000392 B804000000              	mov eax, 4	; sys_write
   465 00000397 BB01000000              	mov ebx, 1	; std_out
   466 0000039C CD80                    	int 80h
   467 0000039E C20200                  	ret 2
   468                                  
   469                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   470                                  ; PROCEDURE
   471                                  ;
   472                                  put_string:
   473 000003A1 B804000000              	mov eax, 4	; sys_write
   474 000003A6 BB01000000              	mov ebx, 1	; std_out
   475 000003AB 8B4C2404                	mov ecx, [esp + 4]	; string pointer
   476 000003AF 8B542408                	mov edx, [esp + 8] ; string length
   477 000003B3 CD80                    	int 80h
   478 000003B5 C20400                  	ret 4
   479                                  
   480                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   481                                  ; PROCEDURE
   482                                  ;
   483                                  get_string:
   484 000003B8 B803000000              	mov eax, 3	; sys_read
   485 000003BD BB00000000              	mov ebx, 0	; std_out
   486 000003C2 8B4C2404                	mov ecx, [esp + 4]	; string pointer
   487 000003C6 8B542406                	mov edx, [esp + 6] ; string length
   488 000003CA CD80                    	int 80h
   489 000003CC C20400                  	ret 4
   490                                  
   491                                  
   492                                  
   493                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   494                                  ; PROCEDURE - pegar numero do teclado e transformar em inteiro
   495                                  ;
   496                                  get_signed_int:
   497                                  	;Pega a string e coloca no vetor do argumento
   498 000003CF B803000000              	mov eax, 3	; sys_read
   499 000003D4 BB00000000              	mov ebx, 0	; (teclado)
   500 000003D9 8B4C2404                	mov ecx, [esp + 4]	; Coloca a string do numero digitado nessa posicao
   501 000003DD BA0B000000              	mov edx, 11 ; string length o maximo é 10 algarismos + o sinal = 11
   502 000003E2 CD80                    	int 80h
   503                                  	;Zera os registradores EBX - resultado 
   504 000003E4 29F6                    	sub esi,esi
   505 000003E6 29DB                    	sub ebx,ebx
   506 000003E8 29C0                    	sub eax,eax
   507 000003EA BF0A000000              	mov edi,10
   508 000003EF 8B4C2404                	mov ecx, [esp + 4] ; LUgar do numero digitado
   509                                  comecoStringToInt: 
   510 000003F3 0FB61C31                	movzx ebx,byte [ecx + esi] ; coloca o digito do numero no ebx
   511 000003F7 80FB2D                  	cmp bl , 45 ; ASCII do '-'
   512 000003FA 7411                    	je	incrementaStringToInt
   513 000003FC 80FB30                  	cmp bl, 48 ; Compara o  digito com 0 - 48d
   514 000003FF 720F                    	jb	fimStringToInt
   515 00000401 80FB39                  	cmp bl , 57 ; Compara o  digito com 9 - 57d
   516 00000404 770A                    	ja 	fimStringToInt
   517 00000406 80EB30                  	sub bl,30h ; transforma o digito em decimal
   518                                  	
   519 00000409 F7E7                    	mul edi ; Pega o resultado parcial(eax) e multiplica por 10
   520 0000040B 01D8                    	add eax,ebx	; O valor final fica em eax
   521                                  incrementaStringToInt:	
   522 0000040D 46                      	inc esi
   523 0000040E EBE3                    	jmp comecoStringToInt
   524                                  fimStringToInt:
   525 00000410 80392D                  	cmp byte [ecx],45 ; Compara e verifica se o numero é negativo
   526 00000413 7507                    	jne finalStringToInt
   527 00000415 29DB                    	sub ebx,ebx	; Zera ebx
   528 00000417 29C3                    	sub ebx,eax	; Torna o numero negativo
   529 00000419 4E                      	dec esi		; O numero negativo tem -1 o tamanho do esi
   530 0000041A 89D8                    	mov eax,ebx	; Coloca ele de novo em EAX
   531                                  finalStringToInt:	
   532 0000041C 8B5C2408                	mov ebx,[esp+8] ; Endereco que guarda o numero inteiro
   533 00000420 8903                    	mov [ebx],eax	; Numero inteiro
   534 00000422 89F1                    	mov ecx,esi		; Tamanho do numero
   535 00000424 C20800                  	ret 8
   536                                  
   537                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   538                                  ; PROCEDURE
   539                                  ;
   540                                  int_to_string:
   541 00000427 8B442408                	mov eax,[esp+8]		; EAX - Valor a ser impresso na tela
   542                                  	;mov eax,[eax]
   543 0000042B BB[31000000]            	mov	ebx,resposta+10	; EBX - Digito menos significativo do numero
   544 00000430 3DFFFFFF7F              	cmp eax,2147483647	; Se for maior que esse valor significa que o numero é negativo
   545 00000435 7730                    	ja negativo
   546                                  continuacao:
   547 00000437 8B4C2404                	mov	ecx,[esp+4]	; ECX - O tanto de algarismos que o numero contem
   548 0000043B BF0A000000              	mov	edi,10
   549                                  					;-2147483648	 Maior numero negativo
   550                                  	
   551                                  TransformaEmString:
   552 00000440 BA00000000              	mov	edx,0
   553 00000445 F7F7                    	div	edi
   554 00000447 83C230                  	add	edx,48
   555 0000044A 8813                    	mov	[ebx],dl
   556 0000044C 4B                      	dec	ebx
   557 0000044D 49                      	dec ecx
   558 0000044E 75F0                    	jnz TransformaEmString
   559                                  fim:
   560 00000450 B804000000              	mov	eax,4			
   561 00000455 BB01000000              	mov	ebx,1			
   562 0000045A B9[27000000]            	mov	ecx,resposta
   563 0000045F BA0B000000              	mov	edx,11
   564 00000464 CD80                    	int	80h
   565                                  	
   566 00000466 C3                      	ret 
   567                                  
   568                                  negativo:
   569 00000467 C605[27000000]2D        	mov byte [resposta],45
   570 0000046E BAFFFFFFFF              	mov edx,4294967295		; Transforma o numero em negativo
   571 00000473 29C2                    	sub edx,eax		
   572 00000475 89D0                    	mov eax,edx				; Recoloca no registrador EAX
   573 00000477 40                      	inc eax					;
   574 00000478 EBBD                    	jmp continuacao			; VOlta ao procedimento normal
   575                                  
   576                                  
   577                                  
   578                                  
   579                                  	
   580                                  
   581                                  
